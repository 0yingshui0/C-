# C-study
C语言学习时留下的代码
//  结构体

//  结构体传参

typedef struct Stu   //  typedef  -  结构体重命名
{
	//  成员变量
	char name[20];
	short age;
	char tele[12];
	char sex[5];
}Stu;   //  重命名的名称

void Print1(Stu tmp)
{
	printf("name: %s\n", tmp.name);
	printf("age: %d\n", tmp.age);
	printf("tele: %s\n", tmp.tele);
	printf("sex: %s\n", tmp.sex);
}
void Print2(Stu* ps)
{
	printf("name: %s\n", ps->name);
	printf("age %d\n", ps->age);
	printf("tele: %s\n", ps->tele);
	printf("sex: %s\n", ps->sex);
}
int main()
{
	Stu s = { "李四",48,"15598886688","男" };
		          //打印结构体数据 
		          // Print1和 Print2哪个更好? 
	Print1(s);   
	Print2(&s);
	              //  答案是:首选Print2函数。原因 :
	              //  函数传参的时候, 参数是需要压栈的。
	              //  如果传递一个结构体对象的时候, 结构体过大, 
		          //  参数压栈的系统开销比较大, 所以会导致性能的下降。
		          //  结论 : 结构体传参的时候, 要传结构体的地址。
	return 0;
}





//struct S
//{
//	int a;
//	char c;
//	char arr[20];
//	double d;
//};
//
//struct T
//{
//	char ch[10];
//	struct S s;
//	char* pc;
//};
//
//int main()
//{
//	char arr[] = "hello world\n";
//	struct T t = { "hehe",{100,'w',"hello world",3.14},arr };
//	printf("%s\n", t.ch);// hehe
//	printf("%s\n", t.s.arr);//  hello world
//	printf("%f\n", t.s.d);//  3.14
//	printf("%s\n", t.pc);//  hello world
//	return 0;
//}


//  描述一个学生 - 一些数据
//  名字
//  年龄
//  电话
//  性别

//  struct  - 结构体关键字  Stu - 结构体标签  struct Stu - 结构体类型

//struct Stu
//{
//	//  成员变量
//	char name[20];
//	short age;
//	char tele[12];
//	char sex[5];
//}s1, s2, s3;    //  s1, s2, s3是三个全局的结构体变量

//typedef struct Stu   //  typedef  -  重命名
//{
//	//  成员变量
//	char name[20];
//	short age;
//	char tele[12];
//	char sex[5];
//}Stu;  //  重命名类型名
//
//int main()
//{
//	struct Stu s1 = { "张三",20,"15234542342","男" };//局部变量
//	Stu s2 = { "旺财",30,"15567892110","保密" };
//
//	return 0;
//}
